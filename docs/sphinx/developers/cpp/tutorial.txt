Tutorial
========


Metadata
--------

Bio-Formats supports several different classes of metadata, from very
basic information about the image dimensions and pixel type to
detailed information about the acquisition hardware and experimental
parameters.  From simplest to most complex, these are:

Core metadata
  Basic information describing an individual 5D image (series),
  including dimension sizes, dimension order and pixel type

Original metadata
  Key-value pairs describing metadata from the original file format
  for the image.  Two forms exist: global metadata for an entire
  dataset (image collection) and series metadata for an individual 5D
  image

Metadata store
  A container for all image metadata providing interfaces to get and
  set individual metadata values.  This is a superset of the core and
  original metadata content (it can represent all values contained
  within the core and original metadata).  It is an alternative
  representation of the OME-XML data model objects, and is used by the
  Bio-Formats reader and writer interfaces.

OME-XML data model objects
  The abstract OME-XML data model is realized as a collection of
  *model objects*.  Classes are generated from the elements of the
  OME-XML data model schema, and a tree of the model objects acts as a
  representation of the OME data model which may be modified and
  manipulated.  The model objects may be created from an OME-XML text
  document, and vice versa.

For the simplest cases of reading and writing image data, the core
metadata interface will likely be sufficient.  If specific individual
parameters from the original file format are needed, then original
metadata may also be useful.  For more advanced processing and
rendering, the metadata store should be the next source of
information, for example to get information about the image scale,
stage position, instrument setup including light sources, light paths,
detectors etc., and access to plate/well information, regions of
interest etc.  Direct access to the OME-XML data model objects is an
alternative to the metadata store, but is more difficult to use;
certain modifications to the data model may only be made via direct
access to the model objects, otherwise the higher-level metadata store
interface should be preferred.

Core metadata
^^^^^^^^^^^^^

Core metadata is accessible through the getter methods in the
:cpp:class:`FormatReader` interface.  These operate on the *current*
series, set using the :cpp:func:`setSeries` method.  The
:cpp:class:`CoreMetadata` objects are also accessible directly using
the :cpp:class:`getCoreMetadataList` method.  The
:cpp:class:`FormatReader` interface should be preferred; the objects
themselves are more of an implementation detail at present.

.. seealso::

  - :doxygen:`CoreMetadata <classome_1_1bioformats_1_1CoreMetadata.html>`
  - :doxygen:`FormatReader <classome_1_1bioformats_1_1FormatReader.html>`


Original metadata
^^^^^^^^^^^^^^^^^

Original metadata is stored in two forms: in a
:cpp:class:`MetadataMap` which is accessible through the
:cpp:class:`FormatReader` interface, which offers access to individual
keys and the whole map for both global and series metadata.  It is
also accessible using the metadata store; original metadata is stored
as an :cpp:class:`XMLAnnotation`.

.. seealso::

  - :doxygen:`MetadataMap <classome_1_1bioformats_1_1MetadataMap.html>`
  - :doxygen:`FormatReader <classome_1_1bioformats_1_1FormatReader.html>`
  - :doxygen:`OriginalMetadataAnnotation <classome_1_1xml_1_1model_1_1OriginalMetadataAnnotation.html>`

Metadata store
^^^^^^^^^^^^^^

Access to metadata is provided via the :cpp:class:`MetadataStore` and
:cpp:class:`MetadataRetrieve` interfaces.  These provide setters and
getters, respectively, to store and retrieve metadata to and from an
underlying abstract metadata store.  The primary store is the
:cpp:class:`OMEXMLMetadata` which stores the metadata in OME-XML data
model objects (see below), and implements both interfaces.  However,
other storage classes are available, and may be used to filter the
stored metadata, combine different stores, or do nothing at all.
Additional storage backends could also be implemented, for example to
allow metadata retrieval from a relational database, or JSON/YAML.

When using :cpp:class:`OMEXMLMetadata` the convenience function
:cpp:func:`createOMEXMLMetadata` is the recommended method for
creating a new instance and then filling it with the content from an
OME-XML document.  This is overloaded to allow the OME-XML to be
obtained from various sources.  For example, from a file:

.. literalinclude:: examples/metadata-io.cpp
   :language: cpp
   :start-after: read-file-example-start
   :end-before: read-file-example-end

Alternatively from a DOM tree:

.. literalinclude:: examples/metadata-io.cpp
   :language: cpp
   :start-after: read-dom-example-start
   :end-before: read-dom-example-end

The convenience function :cpp:func:`getOMEXML` may be used to reverse
the process, i.e. obtain an OME-XML document from the store.  Note the
use of :cpp:func:`convert`.  Only the :cpp:class:`OMEXMLMetadata`
class can dump an OME-XML document, therefore if the source of the
data is another class implementing the :cpp:class:`MetadataRetrieve`
interface, the stored data will need to be copied into an
:cpp:class:`OMEXMLMetadata` instance first.

.. literalinclude:: examples/metadata-io.cpp
   :language: cpp
   :start-after: write-example-start
   :end-before: write-example-end

Conceptually, the metadata store contains lists of objects, accessed
by index (insertion order).  In the example below,
:cpp:func:`getImageCount` method is used to find the number of images.
This is then used to safely loop through each of the available images.
Each of the :cpp:func:`getPixelsSizeA` methods takes the image index
as its only argument.  Internally, this is used to find the
:cpp:class:`Image` model object for the specified index, and then call
the :cpp:func:`getSizeA` method on that object and return the result.
Since objects can contain other objects, some accessor methods require
the use of more than one index.  For example, an :cpp:class:`Image`
object can contain multiple :cpp:class:`Plane` objects.  Similar to
the above example, there is a :cpp:func:`getPlaneCount` method,
however since it is contained by an :cpp:class:`Image` it has an
additional image index argument to get the plane count for the
specified image.  Likewise its accessors such as
:cpp:func:`getPlaneTheZ` take two arguments, the image index and
the plane index.  Internally, these indices will be used to find the
:cpp:class:`Image`, then the :cpp:class:`Plane`, and then call
:cpp:func:`getTheZ`.  When using the :cpp:class:`MetadataRetrieve`
interface with an :cpp:class:`OMEXMLMetadata` store, the methods are
simply a shorthand for navigating through the tree of model objects.

.. literalinclude:: examples/metadata-io.cpp
   :language: cpp
   :start-after: query-example-start
   :end-before: query-example-end

The methods for storing data using the :cpp:class:`MetadataStore`
interface are similar.  The set methods use the same indices as the
get methods, with the value to set as an additional initial argument.
The following example demonstrates how to update dimension sizes for
images in the store:

.. literalinclude:: examples/metadata-io.cpp
   :language: cpp
   :start-after: update-example-start
   :end-before: update-example-end

When adding new objects to the store, as opposed to updating existing
ones, some additional considerations apply.  An new object is added to
the store if the object corresponding to an index does not exist and
the index is the current object count (i.e. one past the end of the
last valid index).  Note that for data model objects with a
:cpp:func:`setID` method, this method alone will trigger insertion and
must be called first, before any other methods which modify the
object.  The following example demonstrates the addition of a new
:cpp:class:`Image` to the store, plus contained :cpp:class:`Plane`
objects.

.. literalinclude:: examples/metadata-io.cpp
   :language: cpp
   :start-after: add-example-start
   :end-before: add-example-end

Full example source: :download:`metadata-io.cpp <examples/metadata-io.cpp>`

.. seealso::

  - :doxygen:`Metadata classes <namespaceome_1_1xml_1_1meta.html>`
  - :doxygen:`createID <namespaceome_1_1bioformats.html#ab3bf80ec03bcf20b199ce2761d48fe01>`
  - :doxygen:`createOMEXMLMetadata <namespaceome_1_1bioformats.html#a094cce3a9581c222d128cc9f366aaa75>`
  - :doxygen:`getOMEXML <namespaceome_1_1bioformats.html#a32e5424991ce09b857ddc0d5be37c4f1>`


OME-XML data model objects
^^^^^^^^^^^^^^^^^^^^^^^^^^

The data model objects are not typically used directly, but are
created, modified and queried using the :cpp:class:`Metadata`
interfaces (above), so in practice these examples should not be
needed.

To create a tree of OME-XML data model objects from OME-XML text:

.. literalinclude:: examples/model-io.cpp
   :language: cpp
   :start-after: read-example-start
   :end-before: read-example-end

In this example, the OME-XML text is read from a file into a DOM tree.
This could have been read directly from a string or stream if the
source was not a file.  The DOM tree is then processed using the
:cpp:class:`OME` root object's :cpp:func:`update` method, which uses
the data from the DOM tree elements to create a tree of corresponding
model objects contained by the root object.

To reverse the process, taking a tree of OME-XML model objects and
converting them back of OME-XML text:

.. literalinclude:: examples/model-io.cpp
   :language: cpp
   :start-after: write-example-start
   :end-before: write-example-end

Here, the :cpp:class:`OME` root object's :cpp:func:`asXMLElement`
method is used to copy the data from the OME root object and its
children into an XML DOM tree.  The DOM tree is then converted to text
for output.

Full example source: :download:`model-io.cpp <examples/model-io.cpp>`

.. seealso::

  - :doxygen:`OME model classes <namespaceome_1_1xml_1_1model.html>`
  - :doxygen:`OME <classome_1_1xml_1_1model_1_1OME.html>`
